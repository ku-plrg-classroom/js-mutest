# JavaScript Mutation Testing Tool

This is a homework assignment, and the goal of this assignment is to create a
simple **JavaScript mutation testing tool** that generates mutants from a given
JavaScript program and measures the mutation score of a test suite as its
adequacy criterion.

It utilizes the [`acorn`](https://github.com/acornjs/acorn) library to parse the
JavaScript code and the [`astring`](https://github.com/davidbonnet/astring)
library to generate the instrumented JavaScript code.

We recommend you to use [`acorn-walk`](https://www.npmjs.com/package/acorn-walk)
to traverse the AST (Abstract Syntax Tree) of the JavaScript code generated by
the `acorn` library.

Please refer to the following documents for more information:
* [Type Definitions for `acorn`](https://github.com/acornjs/acorn/blob/master/acorn/src/acorn.d.ts)
* [Documentation for `acorn-walk` documentation](https://github.com/acornjs/acorn/tree/master/acorn-walk)
* [AST Explorer](https://astexplorer.net/)

> [!NOTE]
>
> While we recommend you use this template to implement the mutation testing
> tool, you can implement your own tool in any programming language, such as
> Python, Java, or C++, from scratch without using it. However, you need to
> provide instructions on how to build and execute your tool. It should produce
> the same set of mutants from a given JavaScript program and provide the
> mutation score of a given test suite.

**Table of Contents**
* [Setup](#setup)
  + [Requirements](#requirements)
  + [Installation](#installation)
  + [Building](#building)
  + [Running](#running)
* [**(Problem #1) Mutation Operation (70 points)**](#problem-1-mutation-operation-70-points)
  + [Arithmetic Operators](#arithmetic-operators)
  + [Array Declarations](#array-declarations)
  + [Assignment Expressions](#assignment-expressions)
  + [Block Statements](#block-statements)
  + [Boolean Literals](#boolean-literals)
  + [Conditions](#conditions)
  + [Equality Operators](#equality-operators)
  + [Logical Operators](#logical-operators)
  + [Object Literals](#object-literals)
  + [Optional Chaining](#optional-chaining)
  + [String Literals](#string-literals)
  + [Unary Operators](#unary-operators)
  + [Update Expressions](#update-expressions)
* [**(Problem #2) Killing All Mutants (30 points)**](#problem-2-killing-all-mutants-30-points)
* [Testing](#testing)
  + [Examples](#examples)


## Setup

### Requirements

| #   | Tool    | Version    |
| --- | ------- | ---------- |
| 1   | Node.js | >= 18.15.0 |
| 2   | npm     | >= 9.8.1   |


### Installation

```bash
npm install && npm run build
```


### Building

When you implement the missing parts, you can **build the project** using the
following command in the terminal:

```bash
npm run build
```

For **watching the changes**, you can use the following command to build the
project automatically:

```bash
npm run build:watch
```


### Running

**After building the project**, you can **run the project** using the
[`./js-mutest`](./js-mutest) executable in the project root directory.
```bash
./js-mutest
```
The `./js-mutest` executable provides the following help message:
```bash
Usage: js-mutest <command> [options]

Commands:
  js-mutest mutate  Generate mutants for the target JS file
  js-mutest test    Perform mutation testing

Options:
  --help     Show help                                                 [boolean]
  --version  Show version number                                       [boolean]
  --detail   Show detailed process                                     [boolean]

Examples:
  js-mutest mutate target.js           Generate mutants for the target JS file
  js-mutest test target.js input.json  Perform mutation testing

You need a command to run `js-mutest.`
```

In addition, you can directly **run the project without building** it as follows:
```bash
npm run start
```

Similarly, for **watching the changes**, you can use the following command to
run the project automatically without building it:

```bash
npm run start:watch
```

For example, you can generate the mutants from the
[`example/arith.js`](./example/arith.js) JavaScript file:

```bash
npm run start mutate example/arith.js
```
Then, it should produce the following output:

```bash
> js-mutest@1.0.0 start
> ts-node src mutate example/arith.js

Mutant #1 [block] [1:33-6:2] `{ ... }` -> `{}`
Mutant #2 [arith] [2:13-2:18] `a + b` -> `a - b`
Mutant #3 [arith] [3:13-3:18] `c * d` -> `c / d`
Mutant #4 [arith] [3:13-3:18] `c * d` -> `c % d`
Mutant #5 [arith] [4:13-4:18] `e / f` -> `e * f`
Mutant #6 [arith] [4:13-4:18] `e / f` -> `e % f`
Mutant #7 [arith] [5:10-5:19] `x - y % z` -> `x + y % z`
Mutant #8 [arith] [5:14-5:19] `y % z` -> `y * z`
Mutant #9 [arith] [5:14-5:19] `y % z` -> `y / z`
```

Or, you can perform mutation testing for the
[`example/arith.js`](./example/arith.js) JavaScript file with a test suite
inferred from the [`input/arith-1.json`](./input/arith-1.json) input file:

```bash
npm run start test example/arith.js input/arith-1.json
```
Then, it should produce the following output:

```bash
> js-mutest@1.0.0 start
> ts-node src test example/arith.js input/arith-1.json

Mutation score: 1 / 9 (11.11%)
  [arith     ]:   0 /   8
  [block     ]:   1 /   1
```

> [!CAUTION]
>
> Please note that it does not produce the above expected output since the
> implementation **is missing**. You need to implement the missing parts to get
> the expected output.

> [!TIP]
> 
> We **HIGHLY RECOMMEND** you to use **`--detail` option** for the command
> `test` to see the detailed process of mutation testing. It shows the following
> information:
>
>   1. **generated mutants**
>   2. **test suite** inferred from the input file
>   3. **whether each mutant is killed** (with a test case kills it) or **alive**
>   4. **mutation score** of the test suite


## (Problem #1) Mutation Operation (70 points)

**Please implement the missing parts** (denoted by `todo()` functions) in the
[`src/impl.ts`](./src/impl.ts) file.

The **goal** of this project to **generate mutants** from a given JavaScript
code and to measure the mutation score of a test suite as its adequacy
criterion. You need to implement the mutation operation for the following
elements:

> [!CAUTION]
>
> If the mutation operation does **not change** the original JavaScript code,
> you should **not** generate the mutant.
>
> For example, `function f() { }` already has an empty block statement, so you
> should **not** generate a mutant by following the mutation operation for 
> [Block Statements](#block-statements).

### Arithmetic Operators

You need to generate mutants whose type is `Arithmetic ("arith")` by replacing
the following arithmetic operators with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Addition to Subtraction                                        | `x + y`                  | `x - y`                  |
| Subtraction to Addition                                        | `x - y`                  | `x + y`                  |
| Multiplication to Division                                     | `x * y`                  | `x / y`                  |
| Multiplication to Modulus                                      | `x * y`                  | `x % y`                  |
| Division to Multiplication                                     | `x / y`                  | `x * y`                  |
| Division to Modulus                                            | `x / y`                  | `x % y`                  |
| Modulus to Multiplication                                      | `x % y`                  | `x * y`                  |
| Modulus to Division                                            | `x % y`                  | `x / y`                  |


### Array Declarations

You need to generate mutants whose type is `ArrayDecl ("array")` by replacing
the arguments of `Array` constructors or the items of array literals with an
empty array:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Array Constructor Arguments to Empty                           | `new Array(x, y)`        | `new Array()`            |
| Array Literal Items to Empty                                   | `[x, y]`                 | `[]`                     |


### Assignment Expressions

You need to generate mutants whose type is `AssignExpr ("assign")` by replacing
the operators of assignment expressions with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Addition Assignment to Subtraction Assignment                  | `x += y`                 | `x -= y`                 |
| Subtraction Assignment to Addition Assignment                  | `x -= y`                 | `x += y`                 |
| Multiplication Assignment to Division Assignment               | `x *= y`                 | `x /= y`                 |
| Division Assignment to Multiplication Assignment               | `x /= y`                 | `x *= y`                 |
| Modulus Assignment to Multiplication Assignment                | `x %= y`                 | `x *= y`                 |
| Left Shift Assignment to Right Shift Assignment                | `x <<= y`                | `x >>= y`                |
| Right Shift Assignment to Left Shift Assignment                | `x >>= y`                | `x <<= y`                |
| Bitwise AND Assignment to Bitwise OR Assignment                | `x &= y`                 | `x \|= y`                |
| Bitwise OR Assignment to Bitwise AND Assignment                | `x \|= y`                | `x &= y`                 |
| Nullish Coalescing Assignment to Logical AND Assignment        | `x ??= y`                | `x &&= y`                |


### Block Statements

You need to generate mutants whose type is `BlockStmt ("block")` by removing the
inner statements of block statements:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Block Statement to Empty Block Statement                      | `{ x; y; }`               | `{}`                     |

### Boolean Literals

You need to generate mutants whose type is `BooleanLiteral ("bool")` by
replacing the boolean literals with the opposite one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| True to False                                                  | `true`                   | `false`                  |
| False to True                                                  | `false`                  | `true`                   |


### Conditions

You need to generate mutants whose type is `Condition ("cond")` by replacing the
conditions of conditional statements or expressions with the `true` or `false`
boolean literals:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Condition of `for` Statement to False                          | `for (; i < n;) { }`     | `for (; false;) { }`     |
| Condition of `while` Statement to False                        | `while (i < n) { }`      | `while (false) { }`      |
| Condition of `do-while` Statement to False                     | `do { } while (i < n)`   | `do { } while (false)`   |
| Condition of `if` Statement to True                            | `if (x) { }`             | `if (true) { }`          |
| Condition of `if` Statement to False                           | `if (x) { }`             | `if (false) { }`         |
| Condition of Conditional Expression to True                    | `x ? y : z`              | `true ? y : z`           |
| Condition of Conditional Expression to False                   | `x ? y : z`              | `false ? y : z`          |


### Equality Operators

You need to generate mutants whose type is `EqualityOp ("equal")` by replacing
the equality operators with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Less Than to Less Than or Equal                                | `x < y`                  | `x <= y`                 |
| Less Than to Greater Than or Equal                             | `x < y`                  | `x >= y`                 |
| Less Than or Equal to Less Than                                | `x <= y`                 | `x < y`                  |
| Less Than or Equal to Greater Than                             | `x <= y`                 | `x > y`                  |
| Greater Than to Greater Than or Equal                          | `x > y`                  | `x >= y`                 |
| Greater Than to Less Than or Equal                             | `x > y`                  | `x <= y`                 |
| Greater Than or Equal to Greater Than                          | `x >= y`                 | `x > y`                  |
| Greater Than or Equal to Less Than                             | `x >= y`                 | `x < y`                  |
| Equal to Not Equal                                             | `x == y`                 | `x != y`                 |
| Equal to Triple Equal                                          | `x == y`                 | `x === y`                |
| Not Equal to Equal                                             | `x != y`                 | `x == y`                 |
| Not Equal to Triple Not Equal                                  | `x != y`                 | `x !== y`                |
| Triple Equal to Triple Not Equal                               | `x === y`                | `x !== y`                |
| Triple Equal to Equal                                          | `x === y`                | `x == y`                 |
| Triple Not Equal to Triple Equal                               | `x !== y`                | `x === y`                |
| Triple Not Equal to Not Equal                                  | `x !== y`                | `x != y`                 |

> [!CAUTION]
>
> You should **not** generate mutants by interchanging the equality (`==`)
> operators with the triple equality (`===`) operators or the non-equality (`!=`)
> operators with the triple non-equality (`!==`) operators if one of the operands
> is `null`.
>
> For example, `null == x` should **not** be mutated to `null === x` or
> `null != x` should **not** be mutated to `null !== x`, vice versa.


### Logical Operators

You need to generate mutants whose type is `LogicalOp ("logical")` by replacing
the logical operators with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Logical AND to Logical OR                                      | `x && y`                 | `x \|\| y`               |
| Logical AND to Nullish Coalescing                              | `x && y`                 | `x ?? y`                 |
| Logical OR to Logical AND                                      | `x \|\| y`               | `x && y`                 |
| Logical OR to Nullish Coalescing                               | `x \|\| y`               | `x ?? y`                 |
| Nullish Coalescing to Logical AND                              | `x ?? y`                 | `x && y`                 |
| Nullish Coalescing to Logical OR                               | `x ?? y`                 | `x \|\| y`               |


### Object Literals

You need to generate mutants whose type is `ObjectLiteral ("object")` by
replacing the properties of object literals with an empty object:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Object Literal Properties to Empty                             | `{ x: y, z: w }`         | `{}`                     |


### Optional Chaining

You need to generate mutants whose type is `OptionalChain ("opt-chain")` by
replacing the optional chaining operators with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Optional Chaining Member Access to Non-Optional                | `x?.y`                   | `x.y`                    |
| Optional Chaining Computed Member Access to Non-Optional       | `x?.[y]`                 | `x[y]`                   |
| Optional Chaining Call to Non-Optional                         | `x?.()`                  | `x()`                    |

> [!CAUTION]
>
> You need to remove all sequential optional chaining operators at once. For
> example, `x?.y?.[z]?.()` should be mutated to `x.y[z]()`.


### String Literals

You need to generate mutants whose type is `StringLiteral ("string")` by
replacing the string literals (or template literals) with an empty string (or
an empty template literal) or the empty string (or the empty template literal)
with the string literals (or template literals) whose contents are `__PLRG__`:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| String Literal to Empty String                                 | `"hello"`                | `""`                     |
| Template Literal to Empty Template Literal                     | ``` `(${x} + 1)` ```     | ```` `` ````             |
| Empty String to String Literal                                 | `""`                     | `"__PLRG__"`             |
| Empty Template Literal to Template Literal                     | ``` `` ```               | ``` `__PLRG__` ```       |

<!-- `` -->


### Unary Operators

You need to generate mutants whose type is `UnaryOp ("unary")` by replacing the
unary operators with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Unary Plus to Unary Minus                                      | `+x`                     | `-x`                     |
| Unary Minus to Unary Plus                                      | `-x`                     | `+x`                     |


### Update Expressions

You need to generate mutants whose type is `UpdateExpr ("update")` by replacing
the operators of update expressions with another one:

| Operator Description                                           | Original                 | Mutant                   |
| -------------------------------------------------------------- | :----------------------: | :----------------------: |
| Prefix Increment to Postfix Increment                          | `++x`                    | `x++`                    |
| Prefix Increment to Prefix Decrement                           | `++x`                    | `--x`                    |
| Postfix Increment to Prefix Increment                          | `x++`                    | `++x`                    |
| Postfix Increment to Postfix Decrement                         | `x++`                    | `x--`                    |
| Prefix Decrement to Postfix Decrement                          | `--x`                    | `x--`                    |
| Prefix Decrement to Prefix Increment                           | `--x`                    | `++x`                    |
| Postfix Decrement to Prefix Decrement                          | `x--`                    | `--x`                    |
| Postfix Decrement to Postfix Increment                         | `x--`                    | `x++`                    |




## (Problem #2) Killing All Mutants (30 points)

**Please construct inputs** (`vectorInputs` in [`src/impl.ts`](./src/impl.ts))
generating a test suite for the [`example/vector.js`](./example/vector.js)
JavaScript file that kills all the generated mutants.

The current `vectorInputs` contains the following inputs and kills only **7 out
of 221** mutants:

```javascript
export const vectorInputs: [string][] = [
  ["$V([])"],
  ["$V([1, 2, 3]).dup()"],
]
```

You need to fill out the `vectorInputs` array with more inputs to kill as many
as possible mutants generated from [`example/vector.js`](./example/vector.js).

> [!TIP]
>
> If you use the dynamic features of JavaScript (e.g., `Function.prototype.call`
> with a manually constructed `this` object), you can kill all the mutants.


## Testing

You can **test the project** using the following command in the terminal:

```bash
npm run test
```

For **watching the changes**, you can use the following command to test the
project automatically:

```bash
npm run test:watch
```

It contains the following 41 tests:

1. **40 different tests** for the correctness of the mutation generation process
   with 14 different target JavaScript files in the [`input`](./input) directory

2. **One test** that checks whether the `vectorInputs` test suite kills all the
   generated mutants for the [`example/vector.js`](./example/vector.js)
   JavaScript file

```bash
$ npm run test
  mutation testing
    arith.js
      ✔ should return the correct mutation score for arith-1.json
      ✔ should return the correct mutation score for arith-2.json
      ✔ should return the correct mutation score for arith-3.json
    array.js
      ✔ should return the correct mutation score for array-1.json
      ✔ should return the correct mutation score for array-2.json
      ✔ should return the correct mutation score for array-3.json
    assign.js
      ✔ should return the correct mutation score for assign-1.json
      ✔ should return the correct mutation score for assign-2.json
      ✔ should return the correct mutation score for assign-3.json
    block.js
      ✔ should return the correct mutation score for block-1.json
      ✔ should return the correct mutation score for block-2.json
      ✔ should return the correct mutation score for block-3.json
    bool.js
      ✔ should return the correct mutation score for bool-1.json
      ✔ should return the correct mutation score for bool-2.json
      ✔ should return the correct mutation score for bool-3.json
    chain.js
      ✔ should return the correct mutation score for chain-1.json
      ✔ should return the correct mutation score for chain-2.json
      ✔ should return the correct mutation score for chain-3.json
    cond.js
      ✔ should return the correct mutation score for cond-1.json
      ✔ should return the correct mutation score for cond-2.json
      ✔ should return the correct mutation score for cond-3.json
    equal.js
      ✔ should return the correct mutation score for equal-1.json
      ✔ should return the correct mutation score for equal-2.json
      ✔ should return the correct mutation score for equal-3.json
    logical.js
      ✔ should return the correct mutation score for logical-1.json
      ✔ should return the correct mutation score for logical-2.json
      ✔ should return the correct mutation score for logical-3.json
    object.js
      ✔ should return the correct mutation score for object-1.json
      ✔ should return the correct mutation score for object-2.json
      ✔ should return the correct mutation score for object-3.json
    string.js
      ✔ should return the correct mutation score for string-1.json
      ✔ should return the correct mutation score for string-2.json
      ✔ should return the correct mutation score for string-3.json
    unary.js
      ✔ should return the correct mutation score for unary-1.json
      ✔ should return the correct mutation score for unary-2.json
      ✔ should return the correct mutation score for unary-3.json
    update.js
      ✔ should return the correct mutation score for update-1.json
      ✔ should return the correct mutation score for update-2.json
      ✔ should return the correct mutation score for update-3.json
    vector.js
      ✔ should return the correct mutation score for vector.json (106ms)

  vectorInputs
    ✔ should have the perfect mutation score for vector.js (189ms)
```


### Examples

The `example` directory contains **14 different target JavaScript files**:

```bash
example
├── arith.js
├── array.js
├── assign.js
├── block.js
├── bool.js
├── chain.js
├── cond.js
├── equal.js
├── logical.js
├── object.js
├── string.js
├── unary.js
├── update.js
└── vector.js
```

The `input` directory contains **40 input files** for the target JavaScript
files in the `example` directory:

```bash
input
├── arith-1.json
├── arith-2.json
├── arith-3.json
├── array-1.json
├── array-2.json
├── array-3.json
├── assign-1.json
├── assign-2.json
├── assign-3.json
├── block-1.json
├── block-2.json
├── block-3.json
├── bool-1.json
├── bool-2.json
├── bool-3.json
├── chain-1.json
├── chain-2.json
├── chain-3.json
├── cond-1.json
├── cond-2.json
├── cond-3.json
├── equal-1.json
├── equal-2.json
├── equal-3.json
├── logical-1.json
├── logical-2.json
├── logical-3.json
├── object-1.json
├── object-2.json
├── object-3.json
├── string-1.json
├── string-2.json
├── string-3.json
├── unary-1.json
├── unary-2.json
├── unary-3.json
├── update-1.json
├── update-2.json
├── update-3.json
└── vector.json
```

Please refer to the following the **expected set of mutants** for each target
JavaScript file:

```bash
out
├── arith.out
├── array.out
├── assign.out
├── block.out
├── bool.out
├── chain.out
├── cond.out
├── equal.out
├── logical.out
├── object.out
├── string.out
├── unary.out
├── update.out
└── vector.out
```

For example, the [`example/arith.js`](./example/arith.js) file has the following
JavaScript code:

```javascript
function arith(a, b, c, d, e, f) {
  const x = a + b;
  const y = c * d;
  const z = e / f;
  return x - y % z;
}
```

Then, there are three input files for the test case of the
[`example/arith.js`](./example/arith.js) file as follows:

1. [`input/arith-1.json`](./input/arith-1.json)
   ```json
   [
     [0, 0, 0, 0, 0, 0]
   ]
   ```
1. [`input/arith-2.json`](./input/arith-2.json)
   ```json
   [
     [0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 2, 2]
   ]
   ```
1. [`input/arith-3.json`](./input/arith-3.json)
   ```json
   [
     [1, 2, 3, 4, 5, 6]
   ]
   ```

The [`out/arith.out`](./out/arith.out) file contains the expected set of mutants
for the [`example/arith.js`](./example/arith.js) file:

```bash
Mutant #1 [block] [1:33-6:2] `{ ... }` -> `{}`
Mutant #2 [arith] [2:13-2:18] `a + b` -> `a - b`
Mutant #3 [arith] [3:13-3:18] `c * d` -> `c / d`
Mutant #4 [arith] [3:13-3:18] `c * d` -> `c % d`
Mutant #5 [arith] [4:13-4:18] `e / f` -> `e * f`
Mutant #6 [arith] [4:13-4:18] `e / f` -> `e % f`
Mutant #7 [arith] [5:10-5:19] `x - y % z` -> `x + y % z`
Mutant #8 [arith] [5:14-5:19] `y % z` -> `y * z`
Mutant #9 [arith] [5:14-5:19] `y % z` -> `y / z`
```
